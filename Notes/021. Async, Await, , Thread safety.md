# 021.  Async, Await, Thread safety

Modern asynchronous .NET applications use two keyword: async and await

The async keyword is added to a method declaration, and its primary purpose is to enable the await keyword withing that method (the keywords were introduced as a pair for backward-compatibility reasons).

An async method should return Task\<T\> if it returns a value, or Task if it does not return a value.

**Avoid async void!**

It is possible to have an async method return void, but you should only do this if you're writing an async event handler. A regular async method without a return should return Task, not void.

An async method begins executing synchronously, just like any other method. Within an async method, the await keyword performs an asynchronous wait on its argument. First, it checks whether the operation is already complete; if it is; it continues executing (synchronously). Otherwise, it will pause the async method and return to an incomplete task. When that operation completes some time later, the async method will resume executing.

Once you start using async, it's best practice to allow it to grow through your code. If you call an async method, the calling method should always await the tas it returns.
## Thread safety
Multithreading solves problems with throughput and responsiveness, but in doing so it introduces new problems.

**A race condition** is a bug that occurs when the outcome of a program depends on which of two or more threads reaches a particular block of code first. Running the program many times produces different results, and the result of any given run can't be repeated.

```csharp
//Gives different results on different runs.
Console.WriteLine("***Bad count***");
for (int i = 0; i < 10; i++)
{
    BadCount();
}
Console.WriteLine("***Good count***");
for (int i = 0; i < 10; i++)
{
    GoodCount();
}
static void BadCount()
{
    int count = 0;

    Task task1 = Task.Run(() => DoCount());
    Task task2 = Task.Run(() => DoCount());

    Task.WaitAll(task1, task2);

    Console.WriteLine($"Count = {count}");

    void DoCount()
    {
        for (int i = 0; i < 10000; i++)
        {
            int temp = count; // Temp = 0;
            temp = temp + 1; // Temp = 1; <-- could jump out here, and the other task might run.
            count = temp; // obvious problems
        }
    }
}
static void GoodCount()
{
    object myLock = new object();

    int count = 0;

    Task task1 = Task.Run(() => DoCount());
    Task task2 = Task.Run(() => DoCount());

    Task.WaitAll(task1, task2);

    Console.WriteLine($"Count = {count}");

    void DoCount()
    {
        for (int i = 0; i < 10000; i++)
        {
            lock (myLock)
            {
                int temp = count; // Temp = 0;
                temp = temp + 1; // Temp = 1; <-- could jump out here, and the other task might run.
                count = temp; // obvious problems
            }         
        }
    }
}
```

A **deadlock** occurs  when each of two threads tries to lock a resource the other has already locked. Neither thread can make any further progress.

```C#
object lockA = new object();
object lockB = new object();

int counter = 0;

Task task1 = Task.Run(() =>
{
	for (int i = 0; i < 1000; i++)
	{
        Thread.Sleep(100);
        lock (lockA)
        {
           lock (lockB)
           {
		        counter++;
                Console.WriteLine(counter);
           }
        }
	}
});

Task task2 = Task.Run(() =>
{
    for (int i = 0; i < 1000; i++)
    {
        Thread.Sleep(250);
        lock (lockB)
        {
            lock (lockA)
            {
                counter++;
                Console.WriteLine(counter);
            }
        }
    }
});
```
## Thread safe Collections
The .NET Framework 4 introduces several collection classes that are both thread-safe and scalable. Multiple threads can safely and efficiently add or remove items from these collections, without requiring additional synchronization in user code. When you write new code, use the concurrent collection classes whenever multiple threads will write to the collection concurrently.

**ConcurrentStack, ConncurrentDictionary, ConcurrentQeue, ConcurrentBag, Blocking collection**